import socket, csv
from network_utils import process_command, load_csv, process_sequence_command

def start_tcp_server(ip, port):
    def handle_client_connection(connection, command_data, structure_data):
        try:
            while True:
                data = connection.recv(4096)
                create_log(f"Recevied command : {data}")
                # if data == b'\xaa\xab\xba\xbb\x00\x00\x00\x00\x00\x01\x00\x01\xcc\xcd\xdc\xdd':
                #     create_log(f"Response 1{data}")
                #     response_data = b"\xee\xef\xfe\xff\x00\x01\x00\x00\x00\x0e\x00\x02\x00\x01\x3f\x80\x00\x00\x3f\x80\x00\x00\x3f\x80\x00\x00\x1d\x7a\xff\xfe\xef\xee"
                #     connection.sendall(response_data)
                # if data == b'\xaa\xab\xba\xbb\x00\x00\x00\x00\x00\x03\x00\x01\xcc\xcd\xdc\xdd':
                #     create_log(f"Response 2{data}")
                #     response_data = b"\xee\xef\xfe\xff\x00\x01\x00\x00\x00\x04\x00\x02\x00\x03\x00\x01\x1d\x7a\xff\xfe\xef\xee"
                #     connection.sendall(response_data)
                # if data == b'\xaa\xab\xba\xbb\x00\x00\x00\x07\x00\x07\x00\x17\x07\x08\x07\xe8\x0f\x05%\xcc\xcd\xdc\xdd':
                #     create_log(f"Response 3{data}")
                #     response_data = b"\xee\xef\xfe\xff\x00\x01\x00\x00\x00\x00\x00\x18\x00\x07\xff\xfe\xef\xee"
                #     connection.sendall(response_data)
                if not data:
                    break
                # The line `responses = process_sequence_command(data, command_data, structure_data)`
                # is calling a function named `process_sequence_command` with three arguments: `data`,
                # `command_data`, and `structure_data`. This function is responsible for processing
                # the incoming data received from a client connection and generating a list of
                # responses based on the provided command data and structure data.
                responses = process_sequence_command(data, command_data, structure_data)
                # The code snippet `for response in responses: connection.sendall(response)` is
                # iterating over a list of responses generated by the `process_sequence_command`
                # function and sending each response back to the client connection using the `sendall`
                # method of the connection object.
                for response in responses:
                    connection.sendall(response)
        except ConnectionResetError:
            print("Connection reset by peer")
        except Exception as e:
            print(f"An error occurred: {e}")
        finally:
            connection.close()
    # The code snippet `server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)` is creating
    # a new socket object using the `socket` module in Python. This socket object is being configured
    # to use the IPv4 address family (`AF_INET`) and the TCP protocol (`SOCK_STREAM`), indicating that
    # it will be a TCP socket.
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((ip, port))
    print(f"Server listening on {ip}:{port}")
    server_socket.listen(1)
       
    
    try:
        command_data = load_csv("./command.csv")
        structure_data = load_csv("./structure.csv")

        # The code snippet `while True: connection, client_address = server_socket.accept()` is
        # creating a loop that continuously listens for incoming client connections on the server
        # socket. When a client connects to the server, the `accept()` method is called on the server
        # socket, which blocks until a client connection is established. Once a connection is
        # accepted, the `accept()` method returns a new socket object representing the connection and
        # the address of the client.
        while True:
            connection, client_address = server_socket.accept()
            print(f"Connection from {client_address}")
            handle_client_connection(connection, command_data, structure_data)
    except KeyboardInterrupt:
        print("Server shutting down.")        
    finally:
        server_socket.close()

def create_log(message):
    # The code snippet you provided is creating a function named `create_log` that is responsible for
    # writing log messages to a CSV file named `cmd_errors.csv`. Here is a breakdown of what the code
    # is doing:
    file_path = "./cmd_errors.csv"
    with open(file_path, mode='a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([message
            ])
if __name__ == "__main__":
    ip = "192.168.10.15"  # Change to your server's IP address
    port = 5485  # Change to the desired port
    start_tcp_server(ip, port)
